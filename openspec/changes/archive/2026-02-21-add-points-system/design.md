# 积分系统设计文档

## Context
用户需要完成项目和需求时获得积分奖励，积分会累加到用户总积分中。项目和需求是两种不同的工作项类型，都需要支持积分功能。

## Goals / Non-Goals

### Goals
- 在项目和需求数据模型中添加积分字段
- 支持手动设置和自动计算积分
- 工作项完成时自动累加积分到用户总积分
- 提供用户总积分查询接口

### Non-Goals
- 不实现复杂的积分规则引擎（如根据完成时间、质量等动态计算）
- 不实现积分历史记录（仅维护总积分）
- 不实现积分兑换功能（未来功能）
- 不实现积分排行榜（未来功能）

## Decisions

### Decision: 积分字段类型
**选择**: `number` 类型，不允许为 undefined/null
**理由**: 简化逻辑，每个工作项都应该有明确的积分值，默认为 0

### Decision: 积分分配方式
**选择**: 支持手动设置和自动计算两种方式
**理由**: 
- 手动设置：提供灵活性，用户可以根据工作复杂度自定义积分
- 自动计算：提供便利性，根据优先级自动计算（high: 10, medium: 5, low: 2）

### Decision: 总积分存储位置
**选择**: 在 User 表中添加 `totalPoints` 字段
**理由**: 
- 简单直接，查询效率高
- 符合当前内存数据库架构
- 未来如需历史记录，可以再扩展

### Decision: 积分累加时机
**选择**: 当工作项状态变更为 `completed` 时自动累加
**理由**: 
- 明确触发时机，避免重复累加
- 状态变更时检查是否从非 completed 变为 completed，避免重复计算

### Decision: 自动计算规则
**选择**: 基于优先级计算
- 项目优先级：high: 20, medium: 10, low: 5
- 需求优先级：critical: 15, high: 10, medium: 5, low: 2
**理由**: 优先级越高，工作量通常越大，积分应该相应增加

## Risks / Trade-offs

### Risk: 重复累加积分
**缓解**: 在状态变更时检查之前的状态，只有从非 completed 变为 completed 时才累加

### Risk: 积分被手动修改导致不一致
**缓解**: 在累加积分时使用原子操作，确保数据一致性

### Trade-off: 实时计算 vs 存储总积分
**选择**: 存储总积分
**理由**: 查询效率更高，但需要维护一致性。当前架构下，存储总积分更合适。

## Migration Plan

1. 为现有项目和需求添加 `points: 0` 默认值
2. 为现有用户添加 `totalPoints: 0` 默认值
3. 对于已完成的项目和需求，需要手动触发一次积分累加（或通过迁移脚本）

## Open Questions
- 是否需要支持积分扣除功能？（当前不考虑）
- 是否需要积分变更历史记录？（当前不考虑，未来可扩展）
