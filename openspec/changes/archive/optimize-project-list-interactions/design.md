## Context

本次变更涉及项目列表页面的交互体验优化，需要解决以下技术挑战：

1. **状态管理策略**: 从全局刷新转向局部更新
2. **数据缓存方案**: 选择合适的缓存库（React Query vs SWR）
3. **变更检测机制**: 准确识别表单是否有未保存的变更
4. **组件重构**: 将骨架屏抽离为可复用组件

## Goals / Non-Goals

### Goals
- 实现项目卡片的局部刷新，避免整页重绘
- 引入数据缓存机制，优化返回列表的体验
- 提供骨架屏组件供项目列表复用
- 防止用户误关闭未保存的编辑内容
- 为所有新功能提供 E2E 测试

### Non-Goals
- 不修改项目详情页的交互逻辑
- 不引入 Redux 等重状态管理库（使用轻量级方案）
- 不修改项目数据模型
- 不添加离线存储功能

## Decisions

### 1. 数据缓存方案: 使用 SWR
**决策**: 使用 Vercel 的 SWR 库实现数据缓存

**原因**:
- SWR 由 Vercel 维护，与 Next.js 生态契合
- 内置缓存、重新验证、错误重试等功能
- API 简洁，学习成本低
- 支持乐观更新和乐观 UI
- 相比 React Query 更轻量

**替代方案考虑**:
- React Query: 功能更强大但较重，需要更多配置
- 自建 Context + useEffect: 需要手动实现缓存逻辑，维护成本高

### 2. 局部刷新策略: 回调更新
**决策**: 通过 onSave 回调返回更新后的项目数据，由父组件更新对应 state

**实现方式**:
```typescript
// 父组件
const handleSaveProject = (updatedProject: Project) => {
  setProjects(prev => prev.map(p => 
    p.id === updatedProject.id ? updatedProject : p
  ));
};

// 子组件（抽屉）
onSave?.(result.project);
```

**原因**:
- 简单直接，无需引入复杂的状态管理
- 与现有组件结构兼容
- 性能足够（只更新单个项目对象引用）

### 3. 变更检测机制: 深度比较
**决策**: 使用深度比较检测表单是否有变更

**实现方式**:
- 在抽屉打开时保存初始数据快照
- 每次字段变更时更新本地状态
- 关闭前比较当前值与初始值
- 使用 `JSON.stringify` 进行简单深度比较（数据量小，性能可接受）

**原因**:
- 项目表单字段数量有限，深度比较开销小
- 实现简单，无需引入 lodash 等库
- 覆盖所有字段类型（包括数组如 goals, tags）

### 4. 骨架屏组件位置: UI 组件库
**决策**: 将骨架屏组件放在 `app/ui/skeletons/` 目录

**原因**:
- 骨架屏是通用 UI 组件，可被多个页面复用
- 遵循项目中现有 UI 组件的组织方式
- 方便统一管理和主题定制

## Risks / Trade-offs

### 风险1: 缓存数据可能过期
- **风险**: 用户在其他设备或标签页修改了项目，缓存数据可能不是最新的
- **缓解**: SWR 会在窗口重新聚焦时自动重新验证数据，同时提供手动刷新按钮

### 风险2: 局部更新可能导致状态不一致
- **风险**: 如果多个组件同时更新项目数据，可能出现竞态条件
- **缓解**: 使用函数式更新确保基于最新状态；编辑时锁定对应项目卡片

### 风险3: 深度比较的性能开销
- **风险**: 如果项目数据变得很大，`JSON.stringify` 比较可能影响性能
- **缓解**: 当前项目数据量小（< 1KB），性能影响可忽略；未来可优化为按需比较

## Migration Plan

### Phase 1: 基础设施
1. 安装 SWR 依赖
2. 创建 `useProjects` hook 封装 SWR 逻辑
3. 验证缓存行为

### Phase 2: 局部刷新
1. 修改 ProjectDrawer，通过回调返回更新数据
2. 修改 ProjectPage，实现局部更新逻辑
3. 移除全局 `fetchProjects` 调用

### Phase 3: 骨架屏
1. 重构 ProjectCardSkeleton，匹配项目卡片布局
2. 移动到 `app/ui/skeletons/`
3. 更新项目列表引用

### Phase 4: 未保存确认
1. 在 ProjectDrawer 中添加变更检测逻辑
2. 实现确认弹窗组件
3. 集成到抽屉关闭流程

### Phase 5: E2E 测试
1. 编写所有功能点的 E2E 测试
2. 验证边界场景
3. 确保测试稳定通过

## Open Questions

无
