## Implementation Tasks

### Phase 1: 安装依赖和基础设置
- [ ] 1.1 安装 SWR 依赖
  ```bash
  pnpm add swr
  ```
- [ ] 1.2 创建 `app/lib/hooks/useProjects.ts` hook
  - 封装 SWR 的 useSWR hook
  - 提供 mutate、isLoading、error 等状态
  - 支持筛选参数缓存键

### Phase 2: 局部刷新实现
- [ ] 2.1 修改 `ProjectDrawer.tsx`
  - 修改 `onSave` 回调签名，返回更新后的 `Project` 对象
  - 编辑模式下保存成功后调用 `onSave?.(result.project)`
  - 创建模式下保存成功后调用 `onSave?.(result.project)`
- [ ] 2.2 修改 `page.tsx`
  - 引入 `useProjects` hook 替换现有的 `fetchProjects`
  - 实现 `handleSaveProject` 函数，局部更新项目列表
  - 实现 `handleCreateProject` 函数，追加新项目
  - 移除全局 `fetchProjects` 调用（保留筛选时刷新）
- [ ] 2.3 验证局部刷新
  - 编辑项目后确认只有对应卡片更新
  - 新增项目后确认追加到列表末尾
  - 删除项目后确认移除对应卡片

### Phase 3: 数据缓存实现
- [ ] 3.1 配置 SWR
  - 设置全局配置（dedupingInterval, refreshInterval 等）
  - 配置缓存键策略
- [ ] 3.2 优化缓存体验
  - 从详情页返回时使用 `keepPreviousData: true`
  - 添加窗口聚焦时重新验证
  - 添加手动刷新按钮
- [ ] 3.3 验证缓存行为
  - 首次加载显示骨架屏
  - 返回时立即显示缓存数据
  - 后台静默更新

### Phase 4: 骨架屏组件化
- [ ] 4.1 重构 `ProjectCardSkeleton`
  - 更新布局匹配 `ProjectCard`
  - 包含所有占位元素（图标、菜单、标题、积分、描述、标签、进度、日期）
  - 保持响应式网格布局
- [ ] 4.2 创建 UI 组件库版本
  ```
  app/ui/skeletons/
  ├── index.ts
  └── project-card-skeleton.tsx
  ```
- [ ] 4.3 更新引用
  - 修改 `page.tsx` 导入路径
  - 更新 `ProjectCardSkeleton.tsx` 重新导出（向后兼容）
- [ ] 4.4 验证骨架屏
  - 布局与项目卡片一致
  - 闪烁动画正常
  - 响应式布局正确

### Phase 5: 未保存确认弹窗
- [ ] 5.1 添加变更检测逻辑
  - 在 `ProjectDrawer` 中添加 `initialProject` state
  - 每次字段变更时比较当前值与初始值
  - 添加 `hasUnsavedChanges` 计算属性
- [ ] 5.2 创建确认弹窗组件
  - 创建 `UnsavedChangesDialog` 组件
  - 包含"保存并关闭"、"放弃更改"、"取消"按钮
  - 支持自定义回调
- [ ] 5.3 集成到抽屉关闭流程
  - 拦截关闭事件（关闭按钮、遮罩层点击、ESC 键）
  - 如有未保存变更显示确认弹窗
  - 根据用户选择执行相应操作
- [ ] 5.4 验证确认弹窗
  - 无变更时直接关闭
  - 有变更时显示确认
  - 三个按钮功能正确

### Phase 6: E2E 测试（基于用户行为）
- [ ] 6.1 创建测试文件
  ```
  apps/e2e/tests/web/project-list.spec.ts
  ```

#### 用户体验测试 - 局部刷新
- [ ] 6.2 测试：编辑项目后的流畅体验
  ```typescript
  // 测试目标：验证编辑项目后其他项目保持不动，无闪烁
  // 不验证：网络请求次数、具体 DOM 操作
  test('编辑项目后流畅的用户体验', async ({ page }) => {
    // 1. 加载列表，记录项目 A 和 B 的初始内容和位置
    // 2. 打开项目 A 的编辑抽屉
    // 3. 修改项目 A 的名称
    // 4. 保存
    // 5. 验证：项目 A 显示新名称
    // 6. 验证：项目 B 的内容和位置与初始状态一致
    // 7. 验证：无明显加载动画或页面闪烁
  });
  ```

- [ ] 6.3 测试：创建项目后的无缝添加
  ```typescript
  // 测试目标：验证新项目被添加，现有项目不受影响
  test('创建项目后无缝添加到列表', async ({ page }) => {
    // 1. 记录当前项目数量和顺序
    // 2. 点击创建按钮
    // 3. 填写项目名称
    // 4. 保存
    // 5. 验证：新项目出现在列表中
    // 6. 验证：原有项目的位置和顺序未改变
    // 7. 验证：无整页刷新
  });
  ```

- [ ] 6.4 测试：删除项目后的平滑移除
  ```typescript
  // 测试目标：验证被删除项目消失，其他项目平滑调整
  test('删除项目后平滑移除', async ({ page }) => {
    // 1. 记录初始项目列表
    // 2. 删除项目 A
    // 3. 验证：项目 A 不再显示在列表中
    // 4. 验证：其他项目仍然存在
    // 5. 验证：列表布局平滑调整
  });
  ```

#### 用户体验测试 - 缓存和加载
- [ ] 6.5 测试：从详情页返回的即时响应
  ```typescript
  // 测试目标：验证返回列表时无需等待，立即显示
  // 不验证：具体缓存实现技术
  test('从项目详情返回时的即时响应', async ({ page }) => {
    // 1. 访问项目列表，等待加载完成
    // 2. 滚动到特定位置，记录位置
    // 3. 点击进入某个项目详情
    // 4. 点击返回按钮
    // 5. 验证：列表立即显示（无明显加载等待）
    // 6. 验证：显示的内容与离开前一致
    // 7. 验证：滚动位置保持
  });
  ```

- [ ] 6.6 测试：网络较慢时的优雅降级
  ```typescript
  // 测试目标：验证弱网环境下用户仍可正常使用
  test('网络较慢时的优雅降级', async ({ page }) => {
    // 1. 加载列表
    // 2. 模拟慢速网络
    // 3. 触发后台数据刷新（如切换筛选或手动刷新）
    // 4. 验证：用户仍能看到列表
    // 5. 验证：可以进行操作（如点击卡片）
    // 6. 验证：数据更新后平滑反映
  });
  ```

- [ ] 6.7 测试：首次加载的加载体验
  ```typescript
  // 测试目标：验证加载占位符的视觉一致性
  test('首次加载的加载体验', async ({ page }) => {
    // 1. 清除缓存或首次访问
    // 2. 拦截 API 请求延迟响应
    // 3. 访问列表页
    // 4. 验证：显示加载占位符（骨架屏）
    // 5. 验证：占位符的结构与真实卡片一致
    // 6. 等待数据加载完成
    // 7. 验证：平滑过渡到真实内容
  });
  ```

- [ ] 6.8 测试：手动刷新获取最新数据
  ```typescript
  // 测试目标：验证用户可以主动获取最新数据
  test('手动刷新获取最新数据', async ({ page }) => {
    // 1. 加载列表
    // 2. 修改某个项目（通过其他方式，如 API 调用）
    // 3. 点击刷新按钮
    // 4. 验证：显示加载状态
    // 5. 验证：更新后的数据显示
  });
  ```

#### 用户体验测试 - 数据保护
- [ ] 6.9 测试：防止未保存数据的意外丢失
  ```typescript
  // 测试目标：验证有未保存修改时显示确认
  test('防止未保存数据的意外丢失', async ({ page }) => {
    // 1. 打开项目编辑抽屉
    // 2. 修改某个字段
    // 3. 尝试关闭抽屉（点击关闭按钮、遮罩层、ESC）
    // 4. 验证：显示确认对话框
    // 5. 验证：对话框包含"保存并关闭"、"放弃更改"、"取消"选项
  });
  ```

- [ ] 6.10 测试：保存并关闭编辑的数据持久化
  ```typescript
  // 测试目标：验证"保存并关闭"选项正常工作
  test('保存并关闭编辑的数据持久化', async ({ page }) => {
    // 1. 打开项目编辑
    // 2. 修改名称
    // 3. 触发关闭确认对话框
    // 4. 点击"保存并关闭"
    // 5. 验证：抽屉关闭
    // 6. 验证：列表显示新名称
    // 7. 刷新页面
    // 8. 验证：新名称仍然显示（已持久化）
  });
  ```

- [ ] 6.11 测试：放弃更改后的数据回滚
  ```typescript
  // 测试目标：验证"放弃更改"选项正常工作
  test('放弃更改后的数据回滚', async ({ page }) => {
    // 1. 记录项目原始名称
    // 2. 打开编辑，修改名称
    // 3. 触发关闭确认对话框
    // 4. 点击"放弃更改"
    // 5. 验证：抽屉关闭
    // 6. 验证：列表显示原始名称
    // 7. 重新打开编辑
    // 8. 验证：显示原始名称（修改已丢弃）
  });
  ```

- [ ] 6.12 测试：取消关闭后继续编辑
  ```typescript
  // 测试目标：验证"取消"选项正常工作
  test('取消关闭后继续编辑', async ({ page }) => {
    // 1. 打开编辑，修改名称
    // 2. 触发关闭确认对话框
    // 3. 点击"取消"
    // 4. 验证：确认对话框消失
    // 5. 验证：抽屉保持打开
    // 6. 验证：修改的内容仍在
    // 7. 可以继续编辑
  });
  ```

- [ ] 6.13 测试：无修改时的流畅关闭
  ```typescript
  // 测试目标：验证无修改时直接关闭，不打断用户
  test('无修改时的流畅关闭', async ({ page }) => {
    // 1. 打开项目编辑
    // 2. 不做任何修改
    // 3. 关闭抽屉
    // 4. 验证：抽屉立即关闭
    // 5. 验证：不显示确认对话框
    // 6. 重新打开编辑
    // 7. 验证：显示原始数据
  });
  ```

#### 辅助测试（边界情况和辅助功能）
- [ ] 6.14 测试：快速连续编辑的稳定性
  ```typescript
  // 测试目标：验证频繁编辑操作不会导致状态混乱
  test('快速连续编辑的稳定性', async ({ page }) => {
    // 1. 快速连续编辑多个项目
    // 2. 验证：每次编辑都正确保存
    // 3. 验证：列表状态保持一致
  });
  ```

- [ ] 6.15 运行所有 E2E 测试并修复问题
  ```bash
  pnpm --filter e2e test:web
  ```

### Phase 7: 验证和文档
- [ ] 7.1 验证所有功能
  - 手动测试所有场景
  - 检查控制台无错误
  - 验证响应式布局
- [ ] 7.2 更新文档
  - 在 PR 中描述变更内容
  - 更新 AGENTS.md（如需要）
- [ ] 7.3 运行完整测试套件
  ```bash
  pnpm test
  pnpm build
  ```

## 依赖关系

```
Phase 1: 基础设置
    ↓
Phase 2: 局部刷新 ← 依赖 Phase 1
    ↓
Phase 3: 数据缓存 ← 依赖 Phase 1, 可与 Phase 2 并行
    ↓
Phase 4: 骨架屏 ← 可独立进行
    ↓
Phase 5: 未保存确认 ← 依赖 Phase 2
    ↓
Phase 6: E2E 测试 ← 依赖 Phase 2, 3, 4, 5
    ↓
Phase 7: 验证 ← 依赖所有前置阶段
```

## 预计工作量

- Phase 1: 0.5 天
- Phase 2: 1 天
- Phase 3: 1 天
- Phase 4: 0.5 天
- Phase 5: 1 天
- Phase 6: 1.5 天
- Phase 7: 0.5 天

**总计: 6 天**

## E2E 测试设计原则

### 1. 基于用户行为
- 关注"用户看到了什么"而非"系统做了什么"
- 测试场景描述用户使用产品的真实流程
- 避免验证具体实现技术（如网络请求次数、具体 DOM 结构）

### 2. 可验证的业务价值
- 每个测试都对应一个用户价值点
- 例如："用户不会意外丢失数据"而非"检测表单变更状态"

### 3. 稳定性
- 测试不依赖实现细节，因此重构不会破坏测试
- 使用稳定的定位器（如角色、标签文本）而非 CSS 选择器

### 4. 可读性
- 测试代码像用户故事一样易读
- 注释说明测试的意图和验证点
